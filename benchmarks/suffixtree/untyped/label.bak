#lang racket/base

(require
  "../base/untyped.rkt"
  "data.rkt")

(require racket/contract)
(require racket/vector)
(require racket/local)
(require racket/list)
;; Label implementation.  Labels are like strings, but also allow for
;; efficient shared slicing.
;;
;; TODO later: see if we can generalize labels to be more than just
;; text strings.  It might be useful to have them as arbitrary
;; elements, perhaps as vectors?

;; FIXME: set custom writer for labels to be displayed for debugging
;; purposes.
;; (http://download.plt-scheme.org/doc/299.400/html/mzscheme/mzscheme-Z-H-11.html#node_sec_11.2.10)


;; label-element? object -> true
;; Every value is considered to be a possible label-element.
(define (t? t)
  (define (is-true? truth)
    (equal? t truth))
  is-true?)

(define (start-sentinel s) ; s will be "sentinel"
  (define (sen-start? sen) ; sen is (gensym 'sentinel)
    (string=? (substring (symbol->string sen) 0 8) s))
  sen-start?)

(define 
  (label-element? obj)
  #|(->i ([obj (or/c char? symbol? void?)])
       [result (obj)
               (t? #t)])|#
  #t)

;; When comparing label elements, we use equal?.
;;

(define/contract label-element-equal?
  (-> label-element? label-element? boolean?)
  equal?) 


(provide
         (rename-out [ext:make-label make-label])
         label-element?
         label-element-equal?
         string->label
         string->label/with-sentinel
         vector->label
         vector->label/with-sentinel
         label->string
         label->string/removing-sentinel
         label->vector
         label-length
         label-ref
         sublabel
         sublabel!
         label-prefix?
         label-equal?
         label-empty?
         label-copy
         label-ref-at-end?
         label-source-id
         label-same-source?
         label-source-eq?)


;; make-label: label-element -> label
;; Constructs a new label from either a string or a vector of things.
(define (ext:make-label label-element)
  (->i ([label-element (or/c string? vector?)])
       [result (label-element)
               label?])
  (cond ((string? label-element) (string->label label-element))
        ((vector? label-element) (vector->label label-element))
        (else
         (error 'make-label "Don't know how to make label from ~S" label-element))))

(define/contract (make-sentinel)
  (-> (and/c symbol? (start-sentinel "sentinel")))
  (gensym 'sentinel))

(define/contract (sentinel? datum)
  (-> any/c boolean?)
  (symbol? datum))

;; vector->label vector
;; Constructs a new label from the input vector.
(define (valid-vector? x)
  (define (valid? v)
    (or/c (vectorof char?) (ormap (and/c symbol? (start-sentinel "sentinel")) (vector->list v))))
  valid?)

(define/contract (vector->label vector)
  (->i ([vector (valid-vector? null)])
       [result (vector)
               label?])
  (make-label (vector->immutable-vector vector)
              0 (vector-length vector)))

;; vector->label vector
;; Constructs a new label from the input vector, with a sentinel
;; symbol at the end.
(define/contract (vector->label/with-sentinel vector)
  (->i ([vector (vectorof char?)])
       [result (vector)
               label?])
  (define N (vector-length vector))
  (define V (make-vector (add1 N) (make-sentinel)))
  (let loop ((i 0))
    (if (< i N)
        (begin (vector-set! V i (vector-ref vector i))
               (loop (add1 i)))
        (vector->label V))))

;; string->label: string -> label
;; Constructs a new label from the input string.
(define/contract (string->label str)
  (->i ([str string?])
       [result (str)
               label?])
  (vector->label (list->vector (string->list str))))


;; string->label/with-sentinel: string -> label
;; Constructs a new label from the input string, attaching a unique
;; sentinel symbol at the end of the label.
;;
;; Note: this label can not be converted in whole back to a string:
;; the sentinel character interferes with string concatenation

(define (end-sentinel sen s) ; "sentinel", str
  (define (sentinel-ending? sen-label) ; label made after str
    (string=? (substring (label->string sen-label) (string-length s)) sen))
  sentinel-ending?)

(define (string->label/with-sentinel str)
  (->i ([str string?])
       [result (str)
               (end-sentinel "sentinel" str)])
  (vector->label/with-sentinel (list->vector (string->list str))))


;; label-length: label -> number?
;; Returns the length of the label.
(define/contract (label-length label)
  (->i ([label label?])
      [result (label)
              (and/c integer? (or/c positive? zero?))])
  (define len (- (label-j label) (label-i label)))
  (unless (index? len) (error "label-length"))
  len)


;; label-ref: label number? -> char
;; Returns the kth element in the label. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (label-ref label k)
  (->i ([label label?]
        [k (and/c integer? (or/c positive? zero?))])
        [result (label k)
                (or/c char? (and/c symbol? (start-sentinel "sentinel")))])
  (unless (index? k) (error "label ref INDEX"))
  (vector-ref (label-datum label) (+ k (label-i label))))


;; sublabel: label number number -> label
;; Gets a slice of the label on the half-open interval [i, j)
(define/contract sublabel
  (->* (label? (and/c (or/c positive? zero?) integer?)) ((and/c (or/c positive? zero?) integer?)) label?)
  (case-lambda
    ((label i)
     (sublabel label i (label-length label)))
    ((label i j)
     (unless (<= i j)
       (error 'sublabel "illegal sublabel [~a, ~a]" i j))
     (make-label (label-datum label)
                 (+ i (label-i label))
                 (+ j (label-i label))))))

;; sublabel!: label number number -> void
;; destructively sets the input label to sublabel.
(define/contract sublabel!
  (->* (label? (and/c integer? (or/c positive? zero?))) ((and/c integer? (or/c positive? zero?))) void?)
  (case-lambda
    ((label i)
     (sublabel! label i (label-length label)))
    ((label i j)
     (begin
       ;; order dependent code ahead!
       (set-label-j! label (+ j (label-i label)))
       (set-label-i! label (+ i (label-i label)))
       (void)))))


;; label-prefix?: label label -> boolean
;; Returns true if the first label is a prefix of the second label
(define/contract (label-prefix? prefix other-label)
  (->i ([prefix label?]
        [other-label label?])
       [result (prefix other-label)
               boolean?])
  (let ((m (label-length prefix))
        (n (label-length other-label)))
    (if (> m n)                       ; <- optimization: prefixes
					; can't be longer.
        #f
        (let loop ((k 0))
          (if (= k m)
              #t
              (and (index? k)
                   (equal? (label-ref prefix k) (label-ref other-label k))
                   (loop (add1 k))))))))


;; label-equal?: label label -> boolean
;; Returns true if the two labels are equal.
(define/contract (label-equal? l1 l2)
  (->i ([l1 label?]
        [l2 label?])
       [result (l1 l2)
               boolean?])
  (and (= (label-length l1) (label-length l2))
       (label-prefix? l1 l2)))


;; label-empty?: label -> boolean
;; Returns true if the label is considered empty
(define (label-empty? label)
  (->i ([label label?])
       [result (label)
               boolean?])
  (>= (label-i label) (label-j label))) ; this is also never used??


;; label->string: label -> string
;; Extracts the string that the label represents.
;; Precondition: the label must have originally come from a string.
;; Note: this operation is expensive: don't use it except for debugging.
(define/contract (label->string label)
  (-> label? string?)
  (define V (label->vector label))
  (define L (for/list
                      ([c (in-vector V)])
              (unless (char? c) (error "label->string invariant broken"))
              c))
  (list->string L))

(define/contract (label->string/removing-sentinel label)
  (-> label? string?)
  (let* ([ln (label-length label)]
         [N (if (and (> ln 0) (sentinel? (label-ref label (sub1 ln))))
                (sub1 ln)
                ln)])
    (build-string N (lambda (i)
                      (unless (index? i) (error "label->string 1"))
                      (let ([val (label-ref label i)])
                        (unless (char? val) (error "label->string 2"))
                        val)))))

;; label->vector: label -> vector
;; Extracts the vector that the label represents.
;; Note: this operation is expensive: don't use it except for debugging.
(define/contract (label->vector label)
  (-> label? vector?)
  (define N (label-length label))
  (define buffer (make-vector N 'X));;'X is a placeholder
    (let loop ((i 0))
      (if (and (< i N) (index? i))
          (begin
            (vector-set! buffer i (label-ref label i))
           (loop (add1 i)))
          (vector->immutable-vector buffer))))


;; label-copy: label->label
;; Returns a copy of the label.
(define (same-as x)
  (define (equals? y)
    (label-equal? x y))
  equals?)

(define/contract (label-copy label)
  (->i ([label label?])
       [result (label)
               (same-as label)])
  (make-label (label-datum label) (label-i label) (label-j label)))


;; label-ref-at-end?: label number -> boolean
(define/contract (label-ref-at-end? label offset)
  (->i ([label label?]
        [offset (or/c (and/c positive? integer?) zero?)])
        [result (label offset)
                boolean?])
                
  (= offset (label-length label)))


;; label-source-id: label -> number
(define (label-source-id label)
  (-> label? number?)
  (eq-hash-code (label-datum label)))

;; label-same-source?: label label -> boolean
(define (label-same-source? label-1 label-2)
  (->i ([label-1 label?]
        [label-2 label?])
       [result (label-1 label-2)
               boolean?])
  (eq? (label-datum label-1) (label-datum label-2)))

;; --- from suffixtree.rkt
(define label-source-eq? label-same-source?)
