(module label racket/base
  (#%module-begin
   (require "data.rkt")
   (require racket/contract)
   (define (label-element? obj) 1)
   (define label-element-equal? equal?)
   (provide
 (contract-out
  [rename ext:make-label make-label
          (->i ([label-element (or/c string? vector?)])
               [result (label-element)
                       (lambda (result) 
                         (and (label? result)
                              (and (= (label-i result) 0)
                                   (= (label-j result) (cond [(string? label-element) (string-length label-element)]
                                                             [(vector? label-element) (vector-length label-element)])))))])]
                                       
  [label-element?
   (->i ([obj any/c])
        [result (obj)
                #t])]
  [label-element-equal?
   (->i ([l1 label-element?]
         [l2 label-element?])
        [result (l1 l2)
                boolean?])]
  [string->label
   (->i ([s string?])
        [result (s)
                (lambda (result)
                  (and (label? result)
                       (and (equal? (label-datum result) s)
                            (and (= (label-i result) 0)
                                 (= (label-j result) (string-length s))))))])]
  [string->label/with-sentinel
   (->i ([s string?])
        [result (s)
                (lambda (result)
                  (and (label? result)
                       (and (symbol? (vector-ref (label-datum result) (- (vector-length (label-datum result)) 1)))
                            (and (equal? (list->string
                                          (vector->list
                                           (vector-take (label-datum result) (- (vector-length (label-datum result)) 1)))) s)
                                 (and (= (label-i result) 0)
                                      (= (label-j result) (+ (string-length s) 1)))))))])]
  [vector->label
   (->i ([vector vector?])
        [result (vector)
                (lambda (result)
                  (and (label? result)
                       (and (equal? (label-datum result) vector)
                            (and (= (label-i result) 0)
                                 (= (label-j result) (vector-length vector))))))])]       
  [vector->label/with-sentinel
   (->i ([vector vector?])
        [result (vector)
                (lambda (result)
                  (and (label? result)
                       (and (symbol? (vector-ref (label-datum result) (- (vector-length (label-datum result)) 1)))
                            (and (equal? (vector-take (label-datum result) (- (vector-length (label-datum result)) 1)) vector)
                                 (and (= (label-i result) 0)
                                      (= (label-j result) (+ (vector-length vector) 1)))))))])]
  [label-length
   (->i ([label (lambda (l)
                  (and (label? l)
                       (and (vector? (label-datum l))
                            (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                 (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))))))])
        [result (label)
                (lambda (result)
                  (and (= (- (label-j label) (label-i label)) result)
                       (and (integer? result)
                            (or (positive? result) (zero? result)))))])]
  [label-ref
   (->i ([label (lambda (l)
                  (and (label? l)
                       (and (vector? (label-datum l))
                            (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                 (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))))))]
         [k (label) (and/c (and/c integer? (or/c positive? zero?)) (<=/c (label-j label)))])
        [result (label k)
                (or/c char? symbol?)])]
  [sublabel
   (->i ([label (lambda (l)
                  (and (label? l)
                       (and (vector? (label-datum l))
                            (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                 (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))))))]
         [n (and/c integer? (or/c positive? zero?))])
        ([num (n) (and/c (and/c integer? (or/c positive? zero?)) (>/c n))])
        [result (label n num)
                (lambda (result)
                  (and (label? result)
                       (and (vector? (label-datum result))
                            (and (symbol? (vector-ref (label-datum result) (- (vector-length (label-datum result)) 1)))
                                 (and (and (integer? (label-i result)) (or (positive? (label-i result)) (zero? (label-i result))))
                                      (and (and (integer? (label-j result)) (or (positive? (label-j result)) (zero? (label-j result))))
                                           (> (label-j result) (label-i result))))))))])]
  [sublabel!
   (->i ([label (lambda (l)
                  (and (label? l)
                       (and (vector? (label-datum l))
                            (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                 (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                      (>= (label-j l) (label-i l)))))))]
         [n (and/c integer? (or/c positive? zero?))])
        ([num (n) (and/c (and/c integer? (or/c positive? zero?)) (>/c n))])
        [result (label n num)
                void?])]
  [label-prefix?
   (->i ([prefix (lambda (l)
                   (and (label? l)
                        (and (vector? (label-datum l))
                             (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                  (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                       (>= (label-j l) (label-i l)))))))]
         [other-label (lambda (l)
                        (and (label? l)
                             (and (vector? (label-datum l))
                                  (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                       (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                            (>= (label-j l) (label-i l)))))))])
        [result (prefix other-label)
                boolean?])]
  [label-equal?
   (->i ([l1 (lambda (l)
               (and (label? l)
                    (and (vector? (label-datum l))
                         (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                              (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                   (>= (label-j l) (label-i l)))))))]
         [l2 (lambda (l)
               (and (label? l)
                    (and (vector? (label-datum l))
                         (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                              (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                   (>= (label-j l) (label-i l)))))))])
        [result (l1 l2)
                boolean?])]
  [label-empty?
   (->i ([label (lambda (l)
                  (and (label? l)
                       (and (vector? (label-datum l))
                            (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                 (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                      (>= (label-j l) (label-i l)))))))])
        [result (label)
                boolean?])]
  [label-copy
   (->i ([label (lambda (l)
                  (and (label? l)
                       (and (vector? (label-datum l))
                            (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                 (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                      (>= (label-j l) (label-i l)))))))])
        [result (label)
                (lambda (l)
                  (and (label? l)
                       (and (vector? (label-datum l))
                            (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                 (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                      (>= (label-j l) (label-i l)))))))])]
   [label-ref-at-end?
    (->i ([label (lambda (l)
                  (and (label? l)
                       (and (vector? (label-datum l))
                            (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                 (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                      (>= (label-j l) (label-i l)))))))]
          [offset (label) (and/c (and/c integer? (or/c positive? zero?)) (<=/c (label-j label)))])
         [result (label offset)
                 boolean?])]
   [label-source-id
    (->i ([label (lambda (l)
                   (and (label? l)
                        (and (vector? (label-datum l))
                             (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                  (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                       (>= (label-j l) (label-i l)))))))])
         [result (label)
                 (and/c integer? (or/c positive? zero?))])]
   [label-same-source?
    (->i ([label-1 (lambda (l)
                     (and (label? l)
                          (and (vector? (label-datum l))
                               (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                    (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                         (>= (label-j l) (label-i l)))))))]
          [label-2 (lambda (l)
                     (and (label? l)
                          (and (vector? (label-datum l))
                               (and (and (integer? (label-i l)) (or (positive? (label-i l)) (zero? (label-i l))))
                                    (and (and (integer? (label-j l)) (or (positive? (label-j l)) (zero? (label-j l))))
                                         (>= (label-j l) (label-i l)))))))])
         [result (label-1 label-2)
                 boolean?])])
   ; these aren't used except for debugging
   label->string
   label->string/removing-sentinel
   label->vector)
   (define (ext:make-label label-element)
     (cond
      ((string? label-element) (string->label label-element))
      ((vector? label-element) (vector->label label-element))
      (else (error 'make-label "Don't know how to make label from ~S" label-element))))
   (define (make-sentinel) (gensym 'sentinel))
   (define (sentinel? datum) (symbol? datum))
   (define (vector->label vector) (make-label (vector->immutable-vector vector) 0 (vector-length vector)))
   (define (vector->label/with-sentinel vector)
     (let* ((N (vector-length vector)) (V (make-vector (add1 N))))
       (vector-set! V N (make-sentinel))
       (let loop ((i 0)) (if (< i N) (begin (vector-set! V i (vector-ref vector i)) (loop (add1 i))) (vector->label V)))))
   (define string->label (let ((f (compose vector->label list->vector string->list))) (lambda (str) (f str))))
   (define string->label/with-sentinel (let ((f (compose vector->label/with-sentinel list->vector string->list))) (lambda (str) (f str))))
   (define (label-length label) (- (label-j label) (label-i label)))
   (define (label-ref label k) (vector-ref (label-datum label) (+ k (label-i label))))
   (define sublabel
     (case-lambda
      ((label i) (sublabel label i (label-length label)))
      ((label i j) (unless (<= i j) (error 'sublabel "illegal sublabel [~a, ~a]" i j)) (make-label (label-datum label) (+ i (label-i label)) (+ j (label-i label))))))
   (define sublabel!
     (case-lambda ((label i) (sublabel! label i (label-length label))) ((label i j) (begin (set-label-j! label (+ j (label-i label))) (set-label-i! label (+ i (label-i label))) (void)))))
   (define (label-prefix? prefix other-label)
     (let ((m (label-length prefix)) (n (label-length other-label)))
       (if (> m n) #f (let loop ((k 0)) (if (= k m) #t (and (equal? (label-ref prefix k) (label-ref other-label k)) (loop (add1 k))))))))
   (define (label-equal? l1 l2) (and (= (label-length l1) (label-length l2)) (label-prefix? l1 l2)))
   (define (label-empty? label) (>= (label-i label) (label-j label)))
   (define (label->string label) (list->string (vector->list (label->vector label))))
   (define (label->string/removing-sentinel label)
     (let* ((ln (label-length label)) (N (if (and (> ln 0) (sentinel? (label-ref label (sub1 ln)))) (sub1 ln) ln))) (build-string N (lambda (i) (label-ref label i)))))
   (define (label->vector label)
     (let* ((N (label-length label)) (buffer (make-vector N)))
       (let loop ((i 0)) (if (< i N) (begin (vector-set! buffer i (label-ref label i)) (loop (add1 i))) (vector->immutable-vector buffer)))))
   (define (label-copy label) (make-label (label-datum label) (label-i label) (label-j label)))
   (define (label-ref-at-end? label offset) (= offset (label-length label)))
   (define (label-source-id label) (eq-hash-code (label-datum label)))
   (define (label-same-source? label-1 label-2) (eq? (label-datum label-1) (label-datum label-2)))
   (provide label-source-eq?)
   (define label-source-eq? label-same-source?)))
